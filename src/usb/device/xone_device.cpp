#include "tusb_option.h"

#define XBONE_KEEPALIVE_TIMER 15000
#define XGIP_ACK_WAIT_TIMEOUT 2000

#define REPORT_QUEUE_INTERVAL 35
//--------------------------------------------------------------------+
// INCLUDE
//--------------------------------------------------------------------+
#include "class/hid/hid.h"
#include "common/tusb_common.h"
#include "device/usbd_pvt.h"
#include "usb/device/xone_device.h"
#include "xgip_protocol.h"
#include <queue>
#include "config.hpp"
#include "main.hpp"
#include "usb/usb_devices.h"

static uint8_t xb1_guide_on[] = {0x01, 0x5b};
static uint8_t xb1_guide_off[] = {0x00, 0x5b};

// Check if Auth is completed (start is 0x01, 0x01, and invalid is 0x01, 0x07)
const uint8_t authReady[] = {0x01, 0x00};

const uint8_t announce_guitar[] = {
    0x7e, 0xed, 0x81, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x6f, 0x0e, 0x48, 0x02,
    0x01, 0x00, 0x00, 0x00, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
const uint8_t xb1_descriptor_guitar[] = {
    0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x00,
    0xB6, 0x00, 0x16, 0x00, 0x1B, 0x00, 0x1C, 0x00, 0x23, 0x00, 0x29, 0x00, 0x75, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x02, 0x03,
    0x04, 0x06, 0x07, 0x05, 0x01, 0x04, 0x05, 0x06, 0x0A, 0x02, 0x20, 0x00, 0x4D, 0x61, 0x64, 0x43,
    0x61, 0x74, 0x7A, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x47, 0x75, 0x69, 0x74, 0x61, 0x72, 0x2E,
    0x53, 0x74, 0x72, 0x61, 0x74, 0x6F, 0x63, 0x61, 0x73, 0x74, 0x65, 0x72, 0x27, 0x00, 0x57, 0x69,
    0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x49, 0x6E, 0x70, 0x75, 0x74,
    0x2E, 0x4E, 0x61, 0x76, 0x69, 0x67, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x43, 0x6F, 0x6E, 0x74, 0x72,
    0x6F, 0x6C, 0x6C, 0x65, 0x72, 0x04, 0x38, 0xE4, 0x2A, 0x0D, 0x7D, 0x7F, 0x33, 0x49, 0x86, 0x93,
    0x30, 0xFC, 0x55, 0x01, 0x8E, 0x77, 0xE7, 0x1F, 0xF3, 0xB8, 0x86, 0x73, 0xE9, 0x40, 0xA9, 0xF8,
    0x2F, 0x21, 0x26, 0x3A, 0xCF, 0xB7, 0x56, 0xFF, 0x76, 0x97, 0xFD, 0x9B, 0x81, 0x45, 0xAD, 0x45,
    0xB6, 0x45, 0xBB, 0xA5, 0x26, 0xD6, 0x77, 0xCE, 0x34, 0x7A, 0xE2, 0x7D, 0xC6, 0x45, 0x8C, 0xA4,
    0x00, 0x42, 0xC0, 0x8B, 0xD9, 0x4A, 0x02, 0x17, 0x00, 0x20, 0x20, 0x00, 0x01, 0x00, 0x14, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00,
    0x21, 0x05, 0x00, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t announce_drum[] = {
    0x7e, 0xed, 0x81, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x38, 0x07, 0x62, 0x42,
    0x01, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
const uint8_t xb1_descriptor_drum[] = {
    0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x00,
    0xAD, 0x00, 0x16, 0x00, 0x1B, 0x00, 0x1C, 0x00, 0x23, 0x00, 0x29, 0x00, 0x6C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x02, 0x03,
    0x04, 0x06, 0x07, 0x05, 0x01, 0x04, 0x05, 0x06, 0x0A, 0x02, 0x17, 0x00, 0x4D, 0x61, 0x64, 0x43,
    0x61, 0x74, 0x7A, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x44, 0x72, 0x75, 0x6D, 0x73, 0x2E, 0x47,
    0x6C, 0x61, 0x6D, 0x27, 0x00, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x58, 0x62, 0x6F,
    0x78, 0x2E, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x2E, 0x4E, 0x61, 0x76, 0x69, 0x67, 0x61, 0x74, 0x69,
    0x6F, 0x6E, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x6C, 0x65, 0x72, 0x04, 0x93, 0x28, 0x18,
    0x06, 0xE0, 0xCC, 0x85, 0x4B, 0x92, 0x71, 0x0A, 0x10, 0xDB, 0xAB, 0x7E, 0x07, 0xE7, 0x1F, 0xF3,
    0xB8, 0x86, 0x73, 0xE9, 0x40, 0xA9, 0xF8, 0x2F, 0x21, 0x26, 0x3A, 0xCF, 0xB7, 0x56, 0xFF, 0x76,
    0x97, 0xFD, 0x9B, 0x81, 0x45, 0xAD, 0x45, 0xB6, 0x45, 0xBB, 0xA5, 0x26, 0xD6, 0x77, 0xCE, 0x34,
    0x7A, 0xE2, 0x7D, 0xC6, 0x45, 0x8C, 0xA4, 0x00, 0x42, 0xC0, 0x8B, 0xD9, 0x4A, 0x01, 0x17, 0x00,
    0x20, 0x0A, 0x00, 0x01, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t announce_ghl[] = {
    0x7B, 0xED, 0x63, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x30, 0x14, 0x9B, 0x07,
    0x01, 0x00, 0x00, 0x00, 0x10, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
const uint8_t xb1_descriptor_ghl[] = {
    0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x01,
    0xCF, 0x00, 0x16, 0x00, 0x1F, 0x00, 0x20, 0x00, 0x27, 0x00, 0x2D, 0x00, 0x8E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x01, 0x02, 0x03, 0x04, 0x06, 0x07, 0x05, 0x01, 0x04, 0x05, 0x06, 0x0A, 0x03, 0x19, 0x00,
    0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E,
    0x49, 0x6E, 0x70, 0x75, 0x74, 0x2E, 0x47, 0x48, 0x37, 0x1A, 0x00, 0x57, 0x69, 0x6E, 0x64, 0x6F,
    0x77, 0x73, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x2E, 0x47, 0x61,
    0x6D, 0x65, 0x70, 0x61, 0x64, 0x27, 0x00, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x58,
    0x62, 0x6F, 0x78, 0x2E, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x2E, 0x4E, 0x61, 0x76, 0x69, 0x67, 0x61,
    0x74, 0x69, 0x6F, 0x6E, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x6C, 0x65, 0x72, 0x04, 0xD9,
    0xFD, 0x12, 0xFD, 0x73, 0x8E, 0xC7, 0x47, 0xA2, 0x31, 0x96, 0x26, 0x8C, 0x38, 0x00, 0x9A, 0x2C,
    0x40, 0x2E, 0x08, 0xDF, 0x07, 0xE1, 0x45, 0xA5, 0xAB, 0xA3, 0x12, 0x7A, 0xF1, 0x97, 0xB5, 0xE7,
    0x1F, 0xF3, 0xB8, 0x86, 0x73, 0xE9, 0x40, 0xA9, 0xF8, 0x2F, 0x21, 0x26, 0x3A, 0xCF, 0xB7, 0x77,
    0xCE, 0x34, 0x7A, 0xE2, 0x7D, 0xC6, 0x45, 0x8C, 0xA4, 0x00, 0x42, 0xC0, 0x8B, 0xD9, 0x4A, 0x03,
    0x17, 0x00, 0x20, 0x0E, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x21, 0x20, 0x00, 0x01, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00,
    0x22, 0x08, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t announce_skylanders[] = {
    0x5B, 0x9F, 0x9F, 0x96, 0x1B, 0x00, 0x00, 0x00, 0x30, 0x14, 0xAB, 0x09,
    0x01, 0x00, 0x00, 0x00, 0x32, 0x02, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
const uint8_t xb1_descriptor_skylanders[] = {
    0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x00,
    0x7E, 0x00, 0x16, 0x00, 0x1B, 0x00, 0x1C, 0x00, 0x23, 0x00, 0x29, 0x00, 0x4D, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x02, 0x03,
    0x04, 0x06, 0x1F, 0x05, 0x01, 0x04, 0x05, 0x06, 0x1F, 0x01, 0x21, 0x00, 0x41, 0x63, 0x74, 0x69,
    0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x53, 0x6B, 0x79, 0x6C,
    0x61, 0x6E, 0x64, 0x65, 0x72, 0x73, 0x2E, 0x50, 0x6F, 0x72, 0x74, 0x61, 0x6C, 0x03, 0x00, 0xA2,
    0x88, 0x77, 0x1F, 0x60, 0xB8, 0x40, 0x9B, 0x36, 0x26, 0xEC, 0x56, 0xC7, 0xC4, 0x52, 0x56, 0xFF,
    0x76, 0x97, 0xFD, 0x9B, 0x81, 0x45, 0xAD, 0x45, 0xB6, 0x45, 0xBB, 0xA5, 0x26, 0xD6, 0x77, 0xCE,
    0x34, 0x7A, 0xE2, 0x7D, 0xC6, 0x45, 0x8C, 0xA4, 0x00, 0x42, 0xC0, 0x8B, 0xD9, 0x4A, 0x01, 0x17,
    0x00, 0x21, 0x1E, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t announce_infinity[] = {
    0x59, 0x80, 0x97, 0x54, 0xF6, 0x9E, 0x00, 0x00, 0x6F, 0x0E, 0x29, 0x02,
    0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x0C, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
const uint8_t xb1_descriptor_infinity[] = {
    0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9E, 0x00,
    0x76, 0x00, 0x16, 0x00, 0x1B, 0x00, 0x1C, 0x00, 0x23, 0x00, 0x29, 0x00, 0x45, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x02, 0x03,
    0x04, 0x06, 0x1F, 0x05, 0x01, 0x04, 0x05, 0x06, 0x1F, 0x01, 0x19, 0x00, 0x44, 0x69, 0x73, 0x6E,
    0x65, 0x79, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x49, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x79,
    0x2E, 0x42, 0x61, 0x73, 0x65, 0x03, 0x3C, 0x17, 0x0D, 0xE9, 0x9B, 0x30, 0xA6, 0x41, 0xA4, 0x77,
    0x82, 0x6E, 0x2C, 0x97, 0xD8, 0x82, 0x56, 0xFF, 0x76, 0x97, 0xFD, 0x9B, 0x81, 0x45, 0xAD, 0x45,
    0xB6, 0x45, 0xBB, 0xA5, 0x26, 0xD6, 0x77, 0xCE, 0x34, 0x7A, 0xE2, 0x7D, 0xC6, 0x45, 0x8C, 0xA4,
    0x00, 0x42, 0xC0, 0x8B, 0xD9, 0x4A, 0x01, 0x17, 0x00, 0x21, 0x20, 0x00, 0x01, 0x00, 0x18, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t announce_ld[] = {
    0xFA, 0x1F, 0x18, 0x6F, 0x51, 0x54, 0x00, 0x00, 0x6F, 0x0E, 0x41, 0x01,
    0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x04, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
const uint8_t xb1_descriptor_ld[] = {
    0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0x00,
    0x7C, 0x00, 0x16, 0x00, 0x1B, 0x00, 0x1C, 0x00, 0x23, 0x00, 0x29, 0x00, 0x4B, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x02, 0x03,
    0x04, 0x06, 0x1F, 0x05, 0x01, 0x04, 0x05, 0x06, 0x1F, 0x01, 0x1F, 0x00, 0x54, 0x54, 0x47, 0x61,
    0x6D, 0x65, 0x73, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x44, 0x69, 0x6D, 0x65, 0x6E, 0x73, 0x69,
    0x6F, 0x6E, 0x73, 0x2E, 0x47, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x03, 0x17, 0x36, 0xC0, 0x53,
    0x67, 0x8C, 0x43, 0x46, 0x9A, 0xA6, 0x3F, 0x5C, 0x22, 0x84, 0xF5, 0x92, 0x56, 0xFF, 0x76, 0x97,
    0xFD, 0x9B, 0x81, 0x45, 0xAD, 0x45, 0xB6, 0x45, 0xBB, 0xA5, 0x26, 0xD6, 0x77, 0xCE, 0x34, 0x7A,
    0xE2, 0x7D, 0xC6, 0x45, 0x8C, 0xA4, 0x00, 0x42, 0xC0, 0x8B, 0xD9, 0x4A, 0x01, 0x17, 0x00, 0x21,
    0x20, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00};

const uint8_t announce_gamepad[] = {
    0x7e, 0xed, 0x8d, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x09, 0x12, 0x82, 0x28,
    0x05, 0x00, 0x11, 0x00, 0x82, 0x0c, 0x00, 0x00, 0x04, 0x05, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
const uint8_t xb1_descriptor_gamepad[] = {
    0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0x00,
    0x9B, 0x00, 0x16, 0x00, 0x1F, 0x00, 0x20, 0x00, 0x27, 0x00, 0x2D, 0x00, 0x4A, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
    0x06, 0x01, 0x02, 0x03, 0x04, 0x06, 0x07, 0x05, 0x01, 0x04, 0x05, 0x06, 0x0A, 0x01, 0x1A, 0x00,
    0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x58, 0x62, 0x6F, 0x78, 0x2E, 0x49, 0x6E, 0x70,
    0x75, 0x74, 0x2E, 0x47, 0x61, 0x6D, 0x65, 0x70, 0x61, 0x64, 0x05, 0x56, 0xFF, 0x76, 0x97, 0xFD,
    0x9B, 0x81, 0x45, 0xAD, 0x45, 0xB6, 0x45, 0xBB, 0xA5, 0x26, 0xD6, 0x2C, 0x40, 0x2E, 0x08, 0xDF,
    0x07, 0xE1, 0x45, 0xA5, 0xAB, 0xA3, 0x12, 0x7A, 0xF1, 0x97, 0xB5, 0xE7, 0x1F, 0xF3, 0xB8, 0x86,
    0x73, 0xE9, 0x40, 0xA9, 0xF8, 0x2F, 0x21, 0x26, 0x3A, 0xCF, 0xB7, 0xFE, 0xD2, 0xDD, 0xEC, 0x87,
    0xD3, 0x94, 0x42, 0xBD, 0x96, 0x1A, 0x71, 0x2E, 0x3D, 0xC7, 0x7D, 0x77, 0xCE, 0x34, 0x7A, 0xE2,
    0x7D, 0xC6, 0x45, 0x8C, 0xA4, 0x00, 0x42, 0xC0, 0x8B, 0xD9, 0x4A, 0x02, 0x17, 0x00, 0x20, 0x20,
    0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x17, 0x00, 0x09, 0x3C, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

XboxOneGamepadDevice::XboxOneGamepadDevice()
{
    keep_alive_timer = to_ms_since_boot(get_absolute_time());
    keep_alive_sequence = 1; // sequence starts at 1?
    virtual_keycode_sequence = 0;
    xb1_guide_pressed = false;
    last_report_counter = 0;

    incomingXGIP = new XGIPProtocol();
    outgoingXGIP = new XGIPProtocol();

    xbone_led_mode = 0;
}

uint16_t XboxOneGamepadDevice::open(tusb_desc_interface_t const *itf_desc, uint16_t max_len)
{
    TU_VERIFY(TUSB_CLASS_VENDOR_SPECIFIC == itf_desc->bInterfaceClass && itf_desc->bInterfaceSubClass == 0x47 &&
                  itf_desc->bInterfaceProtocol == 0xD0,
              0);
    uint16_t drv_len = sizeof(tusb_desc_interface_t) +
                       (itf_desc->bNumEndpoints * sizeof(tusb_desc_endpoint_t));

    TU_VERIFY(max_len >= drv_len, 0);

    uint8_t const *p_desc = (uint8_t const *)itf_desc;
    p_desc = tu_desc_next(p_desc);
    TU_ASSERT(usbd_open_edpt_pair(TUD_OPT_RHPORT, p_desc, itf_desc->bNumEndpoints, TUSB_XFER_INTERRUPT, &m_epout, &m_epin), 0);

    // Prepare for output endpoint
    if (m_epout)
    {
        if (!usbd_edpt_xfer(TUD_OPT_RHPORT, m_epout, epout_buf, sizeof(epout_buf)))
        {
            TU_LOG_FAILED();
            TU_BREAKPOINT();
        }
    }
    xboneDriverState = XboxOneDriverState::READY_ANNOUNCE;
    incomingXGIP->reset();
    outgoingXGIP->reset();
    timer_wait_for_announce = to_ms_since_boot(get_absolute_time());
    return drv_len;
}
bool XboxOneGamepadDevice::interrupt_xfer(uint8_t ep_addr, xfer_result_t result, uint32_t xferred_bytes)
{
    if (tu_edpt_dir(ep_addr) == TUSB_DIR_IN)
    {
        // Input report
        if (XFER_RESULT_SUCCESS == result)
        {
        }
    }
    else
    {
        // Output report
        if (XFER_RESULT_SUCCESS == result)
        {
            GipHeader_t *header = (GipHeader_t *)epout_buf;
            // Parse incoming packet and verify its valid
            incomingXGIP->parse(epout_buf, xferred_bytes);

            uint8_t command = incomingXGIP->getCommand();

            // Setup an ack before we change anything about the incoming packet
            if (incomingXGIP->ackRequired() == true)
            {
                queue_xbone_report((uint8_t *)incomingXGIP->generateAckPacket(), incomingXGIP->getPacketLength());
            }
            if (command == GIP_ACK_RESPONSE)
            {
                waiting_ack = false;
            }
            else if (command == GIP_DEVICE_DESCRIPTOR)
            {
                // setup descriptor packet
                outgoingXGIP->reset(); // reset if anything was in there
                outgoingXGIP->setAttributes(GIP_DEVICE_DESCRIPTOR, incomingXGIP->getSequence(), 1, 1, 0);

                const uint8_t *xboxOneDescriptor = nullptr;
                size_t len = 0;
                switch (subtype)
                {
                case Gamepad:
                case Dancepad:
                case DjHeroTurntable:
                case ProKeys:
                case Taiko:
                case StageKit:
                case Wheel:
                case FlightStick:
                case FightStick:
                case PopNMusic:
                case DJMax:
                case ProjectDiva:
                    xboxOneDescriptor = xb1_descriptor_gamepad;
                    len = sizeof(xb1_descriptor_gamepad);
                    break;
                case GuitarHeroGuitar:
                case RockBandGuitar:
                case ProGuitarMustang:
                case ProGuitarSquire:
                case GuitarFreaks:
                case PowerGigGuitar:
                case RockRevolutionGuitar:
                    xboxOneDescriptor = xb1_descriptor_guitar;
                    len = sizeof(xb1_descriptor_guitar);
                    break;
                case GuitarHeroDrums:
                case RockBandDrums:
                case PowerGigDrum:
                    xboxOneDescriptor = xb1_descriptor_drum;
                    len = sizeof(xb1_descriptor_drum);
                    break;
                case LiveGuitar:
                    xboxOneDescriptor = xb1_descriptor_ghl;
                    len = sizeof(xb1_descriptor_ghl);
                    break;
                case Skylanders:
                    xboxOneDescriptor = xb1_descriptor_skylanders;
                    len = sizeof(xb1_descriptor_skylanders);
                    break;
                case DisneyInfinity:
                    xboxOneDescriptor = xb1_descriptor_infinity;
                    len = sizeof(xb1_descriptor_infinity);
                    break;
                case LegoDimensions:
                    xboxOneDescriptor = xb1_descriptor_ld;
                    len = sizeof(xb1_descriptor_ld);
                    break;
                }
                outgoingXGIP->setData(xboxOneDescriptor, len);
                xboneDriverState = XboxOneDriverState::SEND_DESCRIPTOR;
            }
            else if (command == GIP_SET_STATE)
            {
                // TODO: handle other states
                switch (incomingXGIP->getData()[0])
                {
                case GIP_STATE_START:
                    xboneDriverState = XboxOneDriverState::SETUP_AUTH;
                    xbox_one_powered_on = true;
                    break;
                default:
                    break;
                }
            }
            else if (command == GIP_CMD_LED_ON)
            {
                // Set all player LEDs to on
                report_led_mode = incomingXGIP->getData()[1];       // 1 - turn LEDs on
                report_led_brightness = incomingXGIP->getData()[2]; // 2 - brightness (ignored for now)
            }
            else if (command == GIP_CMD_RUMBLE)
            {
                // TODO: rumble
            }
            else if (command == GIP_AUTH || command == GIP_FINAL_AUTH)
            {
                // TODO: auth
                if (incomingXGIP->getDataLength() == 2 && memcmp(incomingXGIP->getData(), authReady, sizeof(authReady)) == 0)
                {
                    xboneDriverState = AUTH_DONE;
                    auth_completed = true;
                }
                if ((incomingXGIP->getChunked() == true && incomingXGIP->endOfChunk() == true) ||
                    (incomingXGIP->getChunked() == false))
                {
                    // xboxOneAuthData->consoleBuffer.setBuffer(incomingXGIP->getData(), incomingXGIP->getDataLength(),
                    //                                          incomingXGIP->getSequence(), incomingXGIP->getCommand());
                    // xboxOneAuthData->xboneState = GPAuthState::send_auth_console_to_dongle;
                    incomingXGIP->reset();
                }
            }
        }

        // prepare for new transfer
        TU_ASSERT(usbd_edpt_xfer(TUD_OPT_RHPORT, m_epout, epout_buf, CFG_TUD_HID_EP_BUFSIZE));
    }

    return true;
}
bool XboxOneGamepadDevice::control_transfer(uint8_t stage, tusb_control_request_t const *request)
{
    return false;
}

void XboxOneGamepadDevice::queue_xbone_report(void *report, uint16_t report_size)
{
    report_queue_t item;
    memcpy(item.report, report, report_size);
    item.len = report_size;
    report_queue.push(item);
}

bool XboxOneGamepadDevice::send_xbone_usb(uint8_t const *report, uint16_t report_size)
{
    if (tud_ready() &&                                              // Is the device ready?
        (m_epin != 0) && (!usbd_edpt_busy(TUD_OPT_RHPORT, m_epin))) // Is the IN endpoint available?
    {
        usbd_edpt_claim(0, m_epin);                                // Take control of IN endpoint
        usbd_edpt_xfer(0, m_epin, (uint8_t *)report, report_size); // Send report buffer
        usbd_edpt_release(0, m_epin);                              // Release control of IN endpoint

        // we successfully sent the report
        return true;
    }
    return false;
}

void XboxOneGamepadDevice::process_report_queue(uint32_t now)
{
    if (!report_queue.empty() && (now - lastReportQueue) > REPORT_QUEUE_INTERVAL)
    {
        if (send_xbone_usb(report_queue.front().report, report_queue.front().len))
        {
            memcpy(last_report, &report_queue.front().report, report_queue.front().len);
            report_queue.pop();
            lastReportQueue = now;
        }
        else
        {
            sleep_ms(REPORT_QUEUE_INTERVAL); // sleep while we wait, never happens during input only auth
        }
    }
}
void XboxOneGamepadDevice::initialize()
{
}
void XboxOneGamepadDevice::set_ack_wait()
{
    waiting_ack = true;
    waiting_ack_timeout = to_ms_since_boot(get_absolute_time()); // 2 second time-out
}
void XboxOneGamepadDevice::process(bool full_poll)
{
    if (!tud_ready())
    {
        return;
    }
    uint16_t xboneReportSize = 0;

    // Perform update
    uint32_t now = to_ms_since_boot(get_absolute_time());

    // Process our report queue
    process_report_queue(now);

    // Do not add logic until our ACK returns
    if (waiting_ack == true)
    {
        if ((now - waiting_ack_timeout) < XGIP_ACK_WAIT_TIMEOUT)
        {
            return;
        }
        else
        { // ACK wait time out
            waiting_ack = false;
        }
    }
    // printf("%02x\r\n", xboneDriverState);
    switch (xboneDriverState)
    {
    case READY_ANNOUNCE:
        // Xbox One announce must wait around 0.5s before sending
        if (now - timer_wait_for_announce > 500)
        {
            const uint8_t *announcePacket = nullptr;
            switch (subtype)
            {
            case Gamepad:
            case Dancepad:
            case DjHeroTurntable:
            case ProKeys:
            case Taiko:
            case StageKit:
            case Wheel:
            case FlightStick:
            case FightStick:
            case PopNMusic:
            case DJMax:
            case ProjectDiva:
                announcePacket = announce_gamepad;
                break;
            case GuitarHeroGuitar:
            case RockBandGuitar:
            case ProGuitarMustang:
            case ProGuitarSquire:
            case GuitarFreaks:
            case PowerGigGuitar:
            case RockRevolutionGuitar:
                announcePacket = announce_guitar;
                break;
            case GuitarHeroDrums:
            case RockBandDrums:
            case PowerGigDrum:
                announcePacket = announce_drum;
                break;
            case LiveGuitar:
                announcePacket = announce_ghl;
                break;
            case Skylanders:
                announcePacket = announce_skylanders;
                break;
            case DisneyInfinity:
                announcePacket = announce_infinity;
                break;
            case LegoDimensions:
                announcePacket = announce_ld;
                break;
            }
            announcePacket = announce_guitar;
            outgoingXGIP->setAttributes(GIP_ANNOUNCE, 1, 1, 0, 0);
            outgoingXGIP->setData(announcePacket, sizeof(announce_gamepad));
            memcpy(outgoingXGIP->getData() + 3, &now, 3);
            queue_xbone_report(outgoingXGIP->generatePacket(), outgoingXGIP->getPacketLength());
            xboneDriverState = WAIT;
        }
        break;
    case SEND_DESCRIPTOR:
        queue_xbone_report(outgoingXGIP->generatePacket(), outgoingXGIP->getPacketLength());
        if (outgoingXGIP->endOfChunk() == true)
        {
            xboneDriverState = WAIT;
        }
        if (outgoingXGIP->getPacketAck() == 1)
        {
            set_ack_wait();
        }
        break;
    case SETUP_AUTH:
        // TODO: auth
        // Received packet from dongle to console / PC
        // if (xboxOneAuthData->xboneState == GPAuthState::send_auth_dongle_to_console)
        // {
        //     uint16_t len = xboxOneAuthData->dongleBuffer.length;
        //     uint8_t type = xboxOneAuthData->dongleBuffer.type;
        //     uint8_t sequence = xboxOneAuthData->dongleBuffer.sequence;
        //     uint8_t *buffer = xboxOneAuthData->dongleBuffer.data;
        //     bool isChunked = (len > GIP_MAX_CHUNK_SIZE);
        //     outgoingXGIP->reset();
        //     outgoingXGIP->setAttributes(type, sequence, 1, isChunked, 1);
        //     outgoingXGIP->setData(buffer, len);
        //     xboxOneAuthData->xboneState = wait_auth_dongle_to_console;
        //     xboxOneAuthData->dongleBuffer.reset();
        // }

        // // Process auth dongle to console
        // if (xboxOneAuthData->xboneState == GPAuthState::wait_auth_dongle_to_console)
        // {
        //     queue_xbone_report(outgoingXGIP->generatePacket(), outgoingXGIP->getPacketLength());
        //     if (outgoingXGIP->getChunked() == false || outgoingXGIP->endOfChunk() == true)
        //     {
        //         xboxOneAuthData->xboneState = GPAuthState::auth_idle_state;
        //     }
        //     if (outgoingXGIP->getPacketAck() == 1)
        //     { // ACK can happen at different chunks
        //         set_ack_wait();
        //     }
        // }
        break;
    case AUTH_DONE:
    case NOT_READY:
    default:
        break;
    };

    XboxOneGamepad_Data_t *xboneReport = (XboxOneGamepad_Data_t *)epin_buf;

    // No input until auth is ready
    if (auth_completed == false)
    {
        return;
    }

    // Send Keep-Alive every 15 seconds (keep_alive_timer updates if send is successful)
    if ((now - keep_alive_timer) > XBONE_KEEPALIVE_TIMER)
    {
        memset(&xboneReport->header, 0, sizeof(GipHeader_t));
        GIP_HEADER((xboneReport), GIP_KEEPALIVE, 1, keep_alive_sequence);
        xboneReport->header.length = 4;
        static uint8_t keepAlive[] = {0x80, 0x00, 0x00, 0x00};
        memcpy(epin_buf + sizeof(GipHeader_t), &keepAlive, sizeof(keepAlive));
        xboneReportSize = sizeof(GipHeader_t) + sizeof(keepAlive);
        // If successful, update our keep alive timer/sequence
        if (send_xbone_usb(epin_buf, xboneReportSize) == true)
        {
            keep_alive_timer = to_ms_since_boot(get_absolute_time());
            keep_alive_sequence++; // will rollover
            if (keep_alive_sequence == 0)
                keep_alive_sequence = 1;
        }
        return;
    }


    memset(epin_buf, 0, sizeof(XboxOneGamepad_Data_t));
    GIP_HEADER((xboneReport), GIP_INPUT_REPORT, false, last_report_counter);
    xboneReportSize = sizeof(XboxOneGamepad_Data_t);

    for (const auto &mapping : mappings)
    {
        mapping->update(full_poll);
        mapping->update_xboxone(epin_buf);
    }

    // Virtual Keycode Triggered (Pressed or Released)
    if (xb1_guide_pressed != xboneReport->guide)
    {
        xb1_guide_pressed = xboneReport->guide;
        uint8_t new_sequence = virtual_keycode_sequence;
        new_sequence++; // will rollover
        if (new_sequence == 0)
            new_sequence = 1;
        GIP_HEADER((xboneReport), GIP_VIRTUAL_KEYCODE, 1, new_sequence);
        if (xb1_guide_pressed == false)
        {
            xboneReport->header.length = sizeof(xb1_guide_on);
            memcpy(epin_buf + sizeof(GipHeader_t), &xb1_guide_on, sizeof(xb1_guide_on));
            xboneReportSize = sizeof(GipHeader_t) + sizeof(xb1_guide_on);
        }
        else
        {
            xboneReport->header.length = sizeof(xb1_guide_off);
            memcpy(epin_buf + sizeof(GipHeader_t), &xb1_guide_off, sizeof(xb1_guide_off));
            xboneReportSize = sizeof(GipHeader_t) + sizeof(xb1_guide_off);
        }
        if (send_xbone_usb((uint8_t *)&xboneReport, xboneReportSize) == true)
        {
            // On success, update our guide pressed state and virtual key code state
            virtual_keycode_sequence = new_sequence;
            xb1_guide_pressed = !xb1_guide_pressed;
        }
        return;
    }
    // this was set temporarily to make things easier for mapping, so don't actually send it
    xboneReport->guide = false;
    // We changed inputs since generating our last report, increment last report counter (but don't update until success)
    if (memcmp(last_report, epin_buf + sizeof(GipHeader_t), xboneReportSize - sizeof(GipHeader_t)) != 0)
    {
        xboneReportSize = sizeof(XboxOneGamepad_Data_t);
        memcpy(last_report, epin_buf, xboneReportSize);
        xboneReport->header.sequence = last_report_counter + 1;
        if (xboneReport->header.sequence == 0)
            xboneReport->header.sequence = 1;

        // Successfully sent report, actually increment last report counter!
        if (send_xbone_usb(epin_buf, xboneReportSize) == true)
        {
            if (memcmp(last_report, epin_buf + sizeof(GipHeader_t), xboneReportSize - sizeof(GipHeader_t)) != 0)
            {
                last_report_counter++;
                if (last_report_counter == 0)
                    last_report_counter = 1;
                memcpy(last_report, epin_buf + sizeof(GipHeader_t), xboneReportSize);
                return;
            }
        }
    }
}

size_t XboxOneGamepadDevice::compatible_section_descriptor(uint8_t *dest, size_t remaining)
{
    OS_COMPATIBLE_SECTION section = {
        FirstInterfaceNumber : interface_id,
        Reserved : 0x01,
        CompatibleID : "XGIP10",
        SubCompatibleID : {0},
        Reserved2 : {0}
    };
    assert(sizeof(section) <= remaining);
    memcpy(dest, &section, sizeof(section));
    return sizeof(section);
}

size_t XboxOneGamepadDevice::config_descriptor(uint8_t *dest, size_t remaining)
{
    if (!m_eps_assigned)
    {
        m_eps_assigned = true;
        m_epin = next_epin();
        m_epout = next_epout();
        usb_instances_by_epnum[m_epin] = usb_instances[interface_id];
        usb_instances_by_epnum[m_epout] = usb_instances[interface_id];
    }
    uint8_t desc[] = {TUD_XONE_GAMEPAD_DESCRIPTOR(interface_id, m_epin, m_epout)};
    assert(sizeof(desc) <= remaining);
    memcpy(dest, desc, sizeof(desc));
    return sizeof(desc);
}

void XboxOneGamepadDevice::device_descriptor(tusb_desc_device_t *desc)
{
    desc->idVendor = XBOX_ONE_CONTROLLER_VID;
    desc->idProduct = XBOX_ONE_CONTROLLER_PID;
    desc->bDeviceClass = 0xff;
    desc->bDeviceSubClass = 0x47;
    desc->bDeviceProtocol = 0xd0;
}